package jako

import java.io.File
import java.io.FileInputStream
import java.lang.reflect.Field
import java.lang.reflect.Method
import java.lang.reflect.Parameter
import java.nio.charset.Charset
import java.util.jar.JarInputStream
import java.util.zip.ZipInputStream

import com.github.ajalt.mordant.rendering.TextColors.*
import com.github.ajalt.mordant.rendering.TextStyles.*
import com.github.ajalt.mordant.terminal.Terminal

typealias Classes = Map<String, Class<*>>

val ktClass = """\$\d+\.class""".toRegex()
var classes: Classes = mapOf()

val terminal = Terminal()

fun main(args: Array<String>) {

    val isShowWarn = args.find { it == "-warn" } != null

    val srcDir = "/Users/luria/Library/Java/JavaVirtualMachines/graalvm-ce-java11-21.0.0.2/Contents/Home/lib/src.zip"

    val e = getClassNamesFromSource(srcDir)
    var i = 1

    for (cls in e) {
        val c = try {
            Class.forName(cls)
        } catch (_: Error) {
            if (isShowWarn)
                terminal.println("${yellow("[WARN]")} $cls is skipped. (${i++}/${e.size})")
            continue
        } catch (_: Exception) {
            if (isShowWarn)
                terminal.println("${yellow("[WARN]")} $cls is skipped. (${i++}/${e.size})")
            continue
        }

        terminal.println("${cyan("[INFO]")} $cls is completed. (${i++}/${e.size})")

        val tc = TypescriptClass(c)
        val file = File("/Users/luria/dev/dtsout/${tc.name}.d.ts")

        file.writeText(tc.toString(), Charset.forName("UTF-8"))
    }

}


fun getClassNamesFromSource(sourceZipDir: String): List<String> {
    val srcFile = File(sourceZipDir)
    val input = FileInputStream(srcFile)
    val zip = ZipInputStream(input)
    var e = zip.nextEntry
    val r = "java.base/"
    val names = mutableListOf<String>()

    while (e != null) {
        val name = e.name

        if (name.startsWith(r)) {
            val cls = name
                .substring(r.length)
                .replace(File.separatorChar, '.')
                .replace(".java", "")
            names.add(cls)
        }

        e = zip.nextEntry
    }

    return names
}

fun export(jarPath: String) {
    classes = collectClasses(jarPath)

    val path = "scripts/typings"
    val dir = File(path)
    if (!dir.exists()) {
        dir.mkdir()
    }

    if (dir.isDirectory) {
        for ((name, cls) in classes) {
            val f = File("$path/$name.d.ts")
            try {
                f.writeText(cls.toDefinition(name), Charset.forName("UTF-8"))

                println("d.ts file exported into: ${f.absolutePath}")
            } catch (ex: Exception) {
                ex.printStackTrace()
            }
        }
    }
}

fun String.isValidDependency(root: MutableSet<String>, avoidName: String): Boolean {
    when {
        avoidName == this -> return false
        root.find { n -> n == this } != null -> return false
        startsWith("any") -> return false
        startsWith("number") -> return false
        startsWith("Map") -> return false
        startsWith("Set") -> return false
    }

    return !this.isExpectedPrimitives()
}

fun Class<*>.toDefinition(avoidName: String): String {
    var result = ""

    val dependencies = mutableSetOf<String>()

    this.declaredMethods.getDependencies(avoidName).forEach {
        if (it.isValidDependency(dependencies, avoidName)) {
            dependencies.add(it)
        }
    }

    this.declaredFields.getDependencies(avoidName).forEach  {
        if (it.isValidDependency(dependencies, avoidName)) {
            dependencies.add(it)
        }
    }

    for (dep in dependencies) {
        val name = dep.toTypescriptType()
        val isArray = name.contains("[]")
        var elementType = (if (isArray) name.dropLast(2) else name)

        if (elementType.isGeneric()) {
            val tmp = elementType.genericToDefinition()

            if (tmp != null) {
                elementType = tmp
            }
        }

        if (elementType != avoidName && elementType.isValidDependency(dependencies, avoidName)) {
            result += """import $elementType from './$elementType' /* normal dependency */"""
            result += "\n"
        }
    }

    // result += "/* This file was generated by jakots-kt */\n\n"
    val type = when {
        this.isEnum -> "class /* enum: because java enum can has functions */"
        this.isInterface -> "interface"
        // this.isLocalClass or this.isMemberClass or this.isAnonymousClass -> "class"
        else -> "class"
    }

    val superType = if (this.superclass != null) {
        val superClassName = this.superclass.name
        var avoidSuperName = superClassName.avoidConflictName()
        val superTypeResult = when (superClassName) {
            "java.lang.Object",
            "java.lang.Enum" -> ""
            else -> "extends $avoidSuperName "
        }

        if (superClassName.isGeneric()) {
            val tmp = avoidSuperName.genericToDefinition()

            if (tmp != null) {
                avoidSuperName = tmp
            }
        }

        if (superTypeResult.isNotEmpty() && superClassName.isValidDependency(dependencies, avoidName)) {
            result += """import $avoidSuperName from './$avoidSuperName' /* super class dependency */"""
            result += "\n"
        }

        superTypeResult
    } else {
        "/* SuperClass Error */ "
    }

    result += "\n\n"

    result += "declare $type $avoidName $superType{\n\n"

    result += "  /* fields */\n\n"

    for (field in this.declaredFields) {
        // println(field.toDefinition())
        result += "  ${field.toDefinition()}\n"
    }

    result += "  /* methods */\n\n"

    for (method in this.declaredMethods) {
        // println(method.toDefinition())
        result += "  ${method.toDefinition()}\n"
    }

    result += "}\n\n"

    result += "export default $avoidName\n\n"

    return result
}

fun Array<Field>.getDependencies(avoidName: String): Set<String> {
    val result = mutableSetOf<String>()

    this
        .map { it.genericType.typeName }
        .forEach { resultType ->
            val isArray = resultType.contains("[]")
            val elementType = (if (isArray) resultType.dropLast(2) else resultType)
            if (elementType != avoidName && !elementType.isExpectedPrimitives()) {
                result.add(elementType)
            }
        }

    return result
}

fun Array<Method>.getDependencies(avoidName: String): Set<String> {
    val result = mutableSetOf<String>()
    for (method in this) {
        val typeName = method.genericReturnType.typeName
        val isArray = typeName.contains("[]")
        val elementType = (if (isArray) typeName.dropLast(2) else typeName)

        val avName = elementType.avoidConflictName()
        if (avName != avoidName && !typeName.isExpectedPrimitives()) {
            result.add(elementType)
        }

        result.addAll(method.parameterTypes.getDependencies(avoidName))
    }

    return result
}

fun Array<Class<*>>.getDependencies(avoidName: String): Set<String> {
    val result = mutableSetOf<String>()

    this.forEach {
        val typeName = it.typeName
        val isArray = typeName.contains("[]")
        val elementType = (if (isArray) typeName.dropLast(2) else typeName)

        val avName = elementType.avoidConflictName()
        val isAny = elementType == "java.lang.Object"
        if (avName != avoidName && !elementType.isExpectedPrimitives() && !isAny) {
            // println("$elementType is ${elementType.isExpectedPrimitives()}")
            result.add(elementType)
        }
    }

    return result
}

fun Field.toDefinition(): String {
    return "public ${this.name}: ${this.genericType.typeName.toTypescriptType()}"
}

fun Method.toDefinition(): String {
    val className = this.declaringClass.name.split(".").last()

    if (className == this.name) {
        return ""
    }

    val returnType = this.genericReturnType.typeName.toTypescriptType()
    return "public ${this.name}(${this.parameters.toDefinition()}): $returnType"
}

fun Array<Parameter>.toDefinition(): String {
    val map = mutableMapOf<String, String>()
    for (param in this) {
        map += param.name to param.parameterizedType.typeName.toTypescriptType()
    }

    return map.map { "${it.key}: ${it.value}" }.joinToString(", ")
}

fun eprintln(string: String) = System.err.println(string)

fun collectClasses(path: String): Classes {

    val file = File(path)
    val jis = JarInputStream(file.inputStream())
    val result = mutableMapOf<String, Class<*>>()

    var entry = jis.nextJarEntry
    while (entry != null) {
        val isJvClass = ktClass.find(entry.name) == null
        if (entry.name.contains(".class") and isJvClass) {
            val clsName = entry.name
                .replace(".class", "")
                .replace("/", ".")
            val cls = try {
                Class.forName(clsName)
            } catch (ex: Error) {
                eprintln("error in: $clsName ->")
                ex.printStackTrace()
                null
            } catch (ex: Exception) {
                eprintln("error in: $clsName ->")
                ex.printStackTrace()
                null
            }

            if (cls != null) {
                if (!cls.isSynthetic) {
                    result += clsName.avoidConflictName() to cls
                }
            }
        }

        entry = jis.nextJarEntry
    }

    return result
}


fun String.avoidConflictName(): String {
    return this.replace("$", "$$").replace('.', '$')
}

fun String.toTypescriptType(): String {
    val isArray = this.contains("[]")
    val elementType = (if (isArray) this.dropLast(2) else this)
    val isPrimitive = !elementType.contains(".") || elementType.isExpectedPrimitives()
    val isString = elementType == "java.lang.String"

    val isAny = elementType == "java.lang.Object"

    if (isAny) {
        return "any"
    }

    if (isString) {
        return if (isArray) "string[]" else "string"
    }

    if (isPrimitive) {
        return when (elementType.split(".").last().toLowerCase()) {
            "boolean" -> "boolean"

            // "char" ->       "number /* char */"
            "byte" ->       "number /* byte */"
            "int" ->        "number /* int */"
            "integer" ->    "number /* int */"
            "short" ->      "number /* short */"
            "long" ->       "number /* long */"

            "float" ->      "number /* float */"
            "double" ->     "number /* double */"

            "char" ->       "string"
            "string" ->     "string"

            "void" ->       "void"
            else -> elementType
        }
    }

    if (elementType.isGeneric()) {
        val g = elementType.genericToDefinition()

        if (g != null) {
            return g
        }
    }

    return this.avoidConflictName()
}

fun String.isGeneric(): Boolean {
    val fullType = """(.*)<(.*)>""".toRegex().matchEntire(this)
    return fullType != null
}

fun String.genericToDefinition(): String? {
    val fullType = """(.*)<(.*)>""".toRegex().matchEntire(this) ?: return null

    if (this.isGeneric()) {
        val mainType = fullType.groupValues[1].trim().toTypescriptType()
        var genericType = fullType.groupValues[2]
                .trim()
                .split(",")
                .joinToString(", ") {
                    it.toTypescriptType()
                            .replace("?", "T")
                }
        println(genericType)
        if (genericType.isGeneric()) {
            val tmp = genericType.genericToDefinition()

            if (tmp != null) {
                genericType = tmp
            }
        }

        return when (mainType.split(".").last()) {
            "List", "LinkedList", "ArrayDeque" -> "$genericType[]"
            "Map", "HashMap" -> "Map<$genericType>"
            "Set", "HashSet" -> "Set<$genericType>"
            else -> "any" // /* no matched*/// -> $mainType<$genericType> "
        }
    }

    return null
}

fun String.isExpectedPrimitives(): Boolean {
    return when (this.split(".").last().toLowerCase()) {
        "void",
        "boolean",
        "byte",
        "char",
        "int",
        "integer",
        "short",
        "long",
        "float",
        "double",
        "string" -> true
        else -> false
    }
}

fun findClasses(dir: File, packageName: String): List<Class<*>> {
    val classes = mutableListOf<Class<*>>()
    if (!dir.exists()) {
        return classes
    }

    val files = dir.listFiles() ?: arrayOf()

    for (file in files) {
        if (file.isDirectory) {
            classes.addAll(findClasses(file, "$packageName.${file.name}"))
        } else if (file.name.endsWith(".class")) {
            classes += Class.forName("$packageName.${file.name.substring(0, file.name.length - 6)}")
        }
    }

    return classes
}

fun loadClasses(packageName: String): List<Class<*>> {
    val loader = Thread.currentThread().contextClassLoader ?: return listOf()

    val path = packageName.replace(".", "/")
    val resources = loader.getResources(path)
    val dirs = mutableListOf<File>()

    while (resources.hasMoreElements()) {
        val resource = resources.nextElement()
        dirs += File(resource.file)
    }

    val classes = mutableListOf<Class<*>>()
    for (dir in dirs) {
        classes.addAll(findClasses(dir, packageName))
    }

    return classes.toList()
}